package dev.jorel.commandapi.ktannotations

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getDeclaredFunctions
import com.google.devtools.ksp.isAnnotationPresent
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import dev.jorel.commandapi.CommandAPICommand
import dev.jorel.commandapi.annotations.*
import dev.jorel.commandapi.annotations.arguments.*
import dev.jorel.commandapi.arguments.*
import java.io.OutputStreamWriter
import kotlin.reflect.KClass

/**
 * FileEmitter is an anonymous function that is called by the
 * emitter functions to emit a string to the generated file.
 * Is it pretty much the same as: `out.println(...)` but in a shorter manner.
 *
 * @param str The actual line we want to emit.
 * @param newline If we want to emit a newline.
 * Sadly, `newline = true` (default param value) is not possible in anonymous functions.
 */
typealias FileEmitter = (str: String, newline: Boolean) -> Unit

/**
 * The Kotlin Annotation Processor for CommandAPI.
 * Note: This code is full of documentation, so it's easy to understand what does what.
 * @author Lucaskyy
 */
@OptIn(KspExperimental::class) // This is required since we use some "experimental" functions of KSP.
class Annotations(private val codeGenerator: CodeGenerator, private val logger: KSPLogger) : SymbolProcessor {
	val classes = mutableListOf<KSClassDeclaration>()
	private lateinit var resolver: Resolver

	/**
	 * Here we find the list of classes that contain CommandAPI commands.
	 */
	override fun process(resolver: Resolver): List<KSAnnotated> {
		logger.info("Kotlin Command API Processor - starting!")
		this.resolver = resolver
		val fileCount = resolver.getAllFiles().count()
		if (fileCount == 0) {
			logger.warn("No files found to process - halting!")
			return emptyList()
		}
		val commandVisitor = CommandVisitor()
		resolver.getAllFiles().forEach { it.accept(commandVisitor, Unit) }
		if (classes.isEmpty()) {
			logger.warn("No classes found to process - halting!")
			return emptyList()
		}
		return emptyList()
	}

	/**
	 * Here we actually start "processing" the commands.
	 * The reason we don't process them in [process] is because the
	 * KSP will get in an infinite loop, since every time a file is generated
	 * it will do a "multi-round". This is nice if you want to process classes
	 * you already processed, but we don't want to do that. So we find the classes in
	 * [process], then actually process them in [finish] which is only ever called once for
	 * a KSP processor.
	 */
	override fun finish() {
		for (cls in classes) {
			logger.info("Writing command subclass for ${cls.simpleName.asString()}", cls)
			// Create the actual file. This file is placed in "generated/ksp/..."
			codeGenerator.createNewFile(
				// we tell that this generated class is generated "because of" [cls]
				Dependencies(true, cls.containingFile!!),
				cls.containingFile!!.packageName.asString(),
				"${cls.simpleName.asString()}\$Command",
				"java"
			).use { output ->
				OutputStreamWriter(output).use { writer ->
					processCommand(cls) { s, b -> if (b) writer.write("$s\n") else writer.write(s) }
				}
			}
		}
	}

	/**
	 * Kotlin works slightly different with static methods.
	 * In Kotlin, we do:
	 * ```kt
	 * class MyClass {
	 * 	companion object {
	 * 		fun myStaticMethod() {}
	 * 	}
	 * }
	 * ```
	 * Then, to call this in Java, we do:
	 * `MyClass.Companion.myStaticMethod()`.
	 * That `.Companion.` doesn't look nice, let's get rid of it.
	 * ```diff
	 *  class MyClass {
	 *  	companion object {
	 * +		@JvmStatic
	 *  		fun myStaticMethod() {}
	 *  	}
	 *  }
	 * ```
	 * Then, to call this in Java, we do:
	 * `MyClass.myStaticMethod()`.
	 * That's more like it! So now, when processing the class, we expect the static method to be:
	 * - in a companion object
	 * - annotated with @[JvmStatic] (implies above)
	 */
	private fun processCommand(cls: KSClassDeclaration, emit: FileEmitter) {
		val className = cls.simpleName.asString()
		// Preconditions
		val cmp = cls.findCompanionObject()
		if (cmp == null) {
			logger.error("Expected to find a companion object in $className, but found none - halting!", cls)
			return
		}
		// Start writing code
		emit("// This class was generated by the Kotlin CommandAPI Processor. DO NOT EDIT", true)
		emit("package ${cls.containingFile!!.packageName.asString()};", true)
		emit("public class $className\$Command {", true)
		// Register commands function
		emit("@SuppressWarnings(\"unchecked\")", true)
		emit("public static void register() {", true)
		for (fn in cmp.getDeclaredFunctions().filter {
			it.isAnnotationPresent(Default::class) || it.isAnnotationPresent(Subcommand::class)
		}) emitCommand(cls, fn, emit)
		emit("}}", false) // close register() and subclass
	}

	private fun emitCommand(cls: KSClassDeclaration, fn: KSFunctionDeclaration, emit: FileEmitter) {
		val fsn = fn.simpleName.asString()
		val clsFqn = "${cls.qualifiedName!!.asString()}.$fsn"
		logger.info("Writing command for $clsFqn", fn)
		// Preconditions
		if (!fn.isAnnotationPresent(JvmStatic::class)) {
			logger.error("Command $clsFqn must be annotated with @JvmStatic", fn)
			return
		}
		// Start writing code
		val fqn = fqn(CommandAPICommand::class)
		emit("new $fqn(${cls.getAnnotation(Command::class).value.quoted()})", true)
		if (fn.isAnnotationPresent(Subcommand::class)) {
			emitSubcommand(fn, emit)
		}
		emitOptions(cls, emit)
		val mapping = generateArguments(fn, emit)
		emitExecutes(fn, clsFqn, mapping, emit)
		emit(".register();", true)
	}

	private fun emitSubcommand(fn: KSFunctionDeclaration, emit: FileEmitter) {
		val scn = fn.getAnnotation(Subcommand::class).value
		// Preconditions
		if (scn.isEmpty()) {
			logger.error("Invalid subcommand - no subcommand name was found", fn)
			return
		}
		// Start writing code
		val sca = scn.quoted().joinToString()
		val fqn = fqn(MultiLiteralArgument::class)
		emit(".withArguments(", true)
		emit("new $fqn($sca)", true)
		emit(".setListed(false)", true)
		fn.annotation(NeedsOp::class)?.let {
			emit(".withPermission(CommandPermission.OP)", true)
		}
		for (pa in fn.annotations(Permission::class)) {
			val permission = pa.value.quoted()
			emit(".withPermission($permission)", true)
		}
		emit(")", true) // close withArguments()
	}

	private fun emitOptions(cls: KSClassDeclaration, emit: FileEmitter) {
		// @Permission
		for (pa in cls.annotations(Permission::class)) {
			val permission = pa.value.quoted()
			emit(".withPermission($permission)", true)
		}
		// @NeedsOp
		cls.annotation(NeedsOp::class)?.let {
			emit(".withPermission(CommandPermission.OP)", true)
		}
		// @Alias
		cls.annotation(Alias::class)?.let {
			val aliases = it.value.quoted().joinToString()
			emit(".withAliases($aliases)", true)
		}
		// @Help
		cls.annotation(Help::class)?.let {
			if (it.shortDescription.isEmpty()) {
				val desc = it.value.quoted()
				emit(".withFullDescription($desc)", true)
			} else {
				val shortDesc = it.shortDescription.quoted()
				val desc = it.value.quoted()
				emit(".withHelp($shortDesc, $desc)", true)
			}
		}
	}

	private fun generateArguments(fn: KSFunctionDeclaration, emit: FileEmitter): List<String> {
		val mapping = mutableListOf<String>()
		for (parameter in fn.parameters.drop(1)) { // drop first arg, since it's the executer
			val a = parameter.getArgumentAnnotation()
			if (a == null) {
				val pn = parameter.name!!.asString().quoted()
				logger.error("Invalid parameter $pn - no argument annotation was found", parameter)
				throw IllegalArgumentException() // unreachable
			}
			val (ksAnnotation, annotation) = a
			val argType = ksAnnotation.annotationType.resolve().declaration.simpleName.asString().substring(1)
			val argFqn = "$argumentsPackage.$argType"
			emitArgument(argFqn, annotation, parameter, emit)

			val primitive = ksAnnotation.asPrimitive()
			if (primitive.value.size == 1) {
				mapping.add(primitive.value[0])
			} else {
				when (annotation) {
					is AEntitySelectorArgument -> {
						when (annotation.value) {
							EntitySelectorArgument.EntitySelector.MANY_ENTITIES ->
								mapping.add(primitive.value[0])
							EntitySelectorArgument.EntitySelector.MANY_PLAYERS ->
								mapping.add(primitive.value[1])
							EntitySelectorArgument.EntitySelector.ONE_ENTITY ->
								mapping.add(primitive.value[2])
							EntitySelectorArgument.EntitySelector.ONE_PLAYER ->
								mapping.add(primitive.value[3])
						}
					}
					is AScoreHolderArgument -> {
						when (annotation.value) {
							ScoreHolderArgument.ScoreHolderType.MULTIPLE ->
								mapping.add(primitive.value[0])
							ScoreHolderArgument.ScoreHolderType.SINGLE ->
								mapping.add(primitive.value[1])
						}
					}
				}
			}
		}
		return mapping
	}

	private fun emitArgument(argType: String, arg: Annotation, parameter: KSValueParameter, emit: FileEmitter) {
		emit(".withArguments(new $argType", false)
		if (arg is AMultiLiteralArgument || arg is ALiteralArgument) {
			emit("(", false)
		} else {
			val pn = parameter.name!!.asString().quoted()
			emit("($pn", false)
		}

		when (arg) {
			// Number arguments
			is AIntegerArgument -> emit(", ${arg.min}, ${arg.max}", false)
			is ALongArgument -> emit(", ${arg.min}L, ${arg.max}L", false)
			is AFloatArgument -> emit(", ${arg.min}F, ${arg.max}F", false)
			is ADoubleArgument -> emit(", ${arg.min}D, ${arg.max}D", false)

			// Non-number arguments
			is ALocation2DArgument -> emit(", ${LocationType::class.qualifiedName}.${arg.value}", false)
			is ALocationArgument -> emit(", ${LocationType::class.qualifiedName}.${arg.value}", false)
			is AEntitySelectorArgument -> emit(
				", ${EntitySelectorArgument.EntitySelector::class.qualifiedName}.${arg.value}",
				false
			)
			is AScoreHolderArgument -> emit(
				", ${ScoreHolderArgument.ScoreHolderType::class.qualifiedName}.${arg.value}",
				false
			)
			is AMultiLiteralArgument -> emit(", ${arg.value.quoted().joinToString()}", false)
			is ALiteralArgument -> emit(", ${arg.value.quoted()}", false)
		}

		emit(")", false)
		if (arg is ALiteralArgument) {
			emit(".setListed(true)", false)
		}
		emit(")", true)
	}

	private fun emitExecutes(fn: KSFunctionDeclaration, fqn: String, mapping: List<String>, emit: FileEmitter) {
		val executor = fn.parameters.firstOrNull()
		// Preconditions
		if (executor == null) {
			logger.error("Invalid command - no executor was found", fn)
			return
		}
		// Start writing code
		when (executor.type.resolve().declaration.simpleName.asString()) {
			"Player" -> emit(".executesPlayer", false)
			"ConsoleCommandSender" -> emit(".executesConsole", false)
			"BlockCommandSender" -> emit(".executesCommandBlock", false)
			"ProxiedCommandSender" -> emit(".executesProxy", false)
			"NativeProxyCommandSender" -> emit(".executesNative", false)
			"Entity" -> emit(".executesEntity", false)
			"CommandSender" -> emit(".executes", false)
			else -> emit(".executes", false)
		}
		emit("((sender, args) -> {", false)
		if (fn.returnType?.equals(resolver.builtIns.intType) == true) {
			emit("return ", false)
		}
		emit("$fqn(sender", false)
		mapping.forEachIndexed { i, s ->
			emit(", ($s) args[$i]", false)
		}
		emit(");})", true)
	}

	inner class CommandVisitor : KSVisitorVoid() {
		override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
			if (classDeclaration.isAnnotationPresent(Command::class)) {
				classes += classDeclaration
			}
		}

		override fun visitFile(file: KSFile, data: Unit) {
			file.declarations.forEach { it.accept(this, Unit) }
		}
	}

	private fun fqn(cls: KClass<*>): String {
		return cls.qualifiedName!!
	}
}

class AnnotationsProvider : SymbolProcessorProvider {
	override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
		return Annotations(environment.codeGenerator, environment.logger)
	}
}